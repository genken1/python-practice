import random
import sys


# Сократите код в строке №2 до 19 символов без использования функций
# 24 символа
# ['much', 'code', 'wow'][i]
# 19 символов
# 'muchcodewow'[:i + 4]


# Напишите функцию generate_groups(), которая генерирует (не просто выдает готовый)
# список всех названий групп в том виде, который используется в выпадающем списке
# на сайте с результатами от робота kispython.
# возврат названия в новом виде
def generate_groups(str):
    return "{0}{1}".format(str[1], int(str[5:7]))


# Изучите, как работает функция zip().
def do_zip():
    a = [1, 1, -9]
    b = [2, 2.3, 4.5]
    c = ["python", "practice"]
    zipped = zip(a, b, c)
    return list(zipped)  # список из кортежей


# Разберите роль операции * в создании функций с переменным числом аргументов, а также для распаковки
# последовательностей. *digits переменное число входных параметров возврат ввдённых значений В структуре даных tuple
def volumes(*digits):
    return digits


# Реализуйте с помощью zip() функцию transpose() для транспонирования матрицы.
# matrix - матрица исходная
def transpose_matrix(matrix):
    return list(list(i) for i in zip(*matrix))


# Реализуйте генератор докладов по цифровой экономике.
def economy_generator():
    arr1 = ['Коллеги,', 'В то же время,', 'Однако,', 'Тем не менее,', 'Следовательно,', 'Соответственно,',
            'Вместе с тем,', 'С другой стороны,']
    arr2 = ['парадигма цифровой экономики', 'контeкст цифровой трансформации', 'диджитализация бизнeс-процессов',
            'прагматичный подход к цифровым платформам', 'совокупность сквозных тeхнологий',
            'программа прорывных исслeдований', 'ускорeниe блокчeйн-транзакций', 'экспоненциальный рост Big Data']
    arr3 = ["открывает новые возможности для", "выдвигает новые требования", "несёт в себе риски",
            "расширяет горизонты", "заставляет искать варианты",
            "не оставляет шанса для", "повышает вероятность", "обостряет проблему"]
    arr4 = ["дальнейшего углубления", "бюджетного финансирования", "синергетического эффекта",
            "компрометации конфиденциальных", "универсальной коммодитизации",
            "несанкционированной кастомизации", "нормативного регулирования", "практического применения"]
    arr5 = ["знаний и компетенций.", "непроверенных гипотез.", "волатильных активов.",
            "опасных экспериментов.", "государственно-частных партнёрств.",
            "цифровых следов граждан.", "нежелательных последствий.", "внезапных открытий."]
    return random.choice(arr1) + " " + random.choice(arr2) + " " + random.choice(arr3) + " " + random.choice(
        arr4) + " " + random.choice(arr5)


# Реализуйте свою версию print(). Постарайтесь использовать максимум возможностей настоящей print().
# Для вывода используйте функцию sys.stdout.write(). *args - входные аргументы sep - раделитель данных,
# end - последний символ строки sys.stdout.write - вывод
def new_print(*args, sep=" ", end="\n"):
    sys.stdout.write(sep.join(str(i) for i in args) + end)


# Реализуйте функцию, которая принимает только именованные аргументы. При передаче позиционного аргумента Питон
# должен выдать ошибку. **args - исходные параметры на возврат словарь ключ-значение
def get_only_named_args(**args):
    return args


# Реализуйте генератор случайных данных ФИО.
def fio_generator():
    names = ['Август', 'Августин', 'Авраам', 'Аврора', 'Агата', 'Агафон', 'Агнесса', 'Агния', 'Ада', 'Аделаида',
             'Аделина',
             'Акулина', 'Александр', 'Александра', 'Алексей', 'Алена', 'Алина', 'Алиса', 'Алла', 'Алсу', 'Альберт',
             'Альбина', 'Амалия', 'Анастасий', 'Анастасия', 'Анатолий', 'Ангелина', 'Андрей', 'Анжела', 'Анжелика',
             'Анисий', 'Анна', 'Антон', 'Антонина', 'Анфиса', 'Аполлинарий', 'Аполлон', 'Арина', 'Аристарх', 'Аркадий',
             'Арсен', 'Арсений', 'Артем', 'Артемий', 'Артур', 'Архип', 'Ася', 'Бенедикт', 'Богдан', 'Божена',
             'Болеслав',
             'Борис', 'Борислав', 'Бронислав', 'Бронислава', 'Булат', 'Вадим', 'Валентин', 'Валентина', 'Валерий',
             'Валерия', 'Ванда', 'Варвара', 'Василий', 'Василиса', 'Венера', 'Вениамин', 'Вера', 'Вероника', 'Викентий',
             'Виктор', 'Виктория', 'Вилен', 'Виолетта', 'Виссарион', 'Вита', 'Виталий', 'Влад', 'Владимир', 'Владислав',
             'Владислава', 'Владлен', 'Вольдемар', 'Всеволод', 'Захар', 'Зинаида', 'Зиновий', 'Злата', 'Зорий',
             'Зоряна']

    ignore = ['Ю', 'Ь', 'Ъ', 'Й', 'Ё', 'Ы']
    consonant = ['б', 'в', 'г', 'д', 'ж', 'з', 'к', 'л', 'м', 'н', 'п', 'р', 'с', 'т', 'ф', 'х', 'ц', 'ч', 'ш', 'щ']
    vowel = ['а', 'я', 'о', 'е', 'у', 'ю', 'ы', 'и', 'э', 'e']
    random_end_words = ['ов', 'ев', 'ин', 'ын', 'ский', 'цкий', 'ской', 'цкой', 'ой', 'ий', 'енков', 'их', 'ых', 'ко']
    at = [chr(x) for x in range(ord('А'), ord('Я') + 1) if chr(x) not in ignore]

    full_name = random.choice(names) + " " + random.choice(at) + ". "
    for i in range(random.randint(1, 3)):
        if i == 0:
            full_name += random.choice(consonant).upper()
        else:
            full_name += random.choice(consonant)
        full_name += random.choice(vowel)
    full_name = full_name + random.choice(consonant) + random.choice(random_end_words)
    return print(full_name)


# Напишите функцию generate_array(dim1, dim2, dim3, ...) для создания
# многомерного массива с помощью вложенных списков.
# возврат многомерного массива
def generate_array(*dim):
    return [*dim]


if __name__ == '__main__':
    assert volumes(1, 2, 3, 4, 5) == (1, 2, 3, 4, 5)
    assert transpose_matrix([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]]
    assert get_only_named_args(key='x', value='1') == {'key': 'x', 'value': '1'}
    assert generate_array([1, 2], [3, 4], [5, 6]) == [[1, 2], [3, 4], [5, 6]]
    assert generate_groups("ИКБО-01-19") == "К1"
    assert do_zip() == [
        (1, 2, 'python'),
        (1, 2.3, 'practice')
    ]

    print("func_print()->", "python", [5, 8], None, True, sep="\t->\t", end="%\n")
    new_print("func_print()->", "python", [5, 8], None, True, sep="\t->\t", end="%\n")
